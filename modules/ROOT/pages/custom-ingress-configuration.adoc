= Configure Ingress for Runtime Fabric on Self-Managed Kubernetes

[IMPORTANT]
====
This content refers to configuring ingress on Runtime Fabric for versions 1.10 and later. Refer to the documentation for versions 1.8 or 1.9 for previous ingress configuration instructions.
==== 

Anypoint Runtime Fabric on Self-Managed Kubernetes enables you to specify custom Ingress configurations using an ingress resource template. In a template, similar to a https://kubernetes.io/docs/concepts/services-networking/ingress/[Kubernetes ingress spec^], you can specify annotations, `ingressClassName`, and HTTP and HTTPs rules. 

If you do not apply an ingress resource template for an application, you can’t add ingress endpoints when you deploy it.  

[IMPORTANT]
====
The ingress controller included with Google Kubernetes Engine (GKE) provisions a separate HTTP load balancer per application by default. Refer to https://help.mulesoft.com/s/article/Default-Ingress-Controller-Behavior-with-Runtime-Fabric-on-GKE[Default Ingress Controller Behavior with Runtime Fabric on GKE^] for more information.

AWS Application Load Balancers have similar behavior unless you use the group.name annotation. Refer to https://docs.aws.amazon.com/eks/latest/userguide/alb-ingress.html[Application load balancing on Amazon EKS^] for details. 
====

== Benefits of Custom Ingress Resource Templates

Using custom ingress resource templates in Runtime Fabric enables you to take advantage of native Kubernetes ingress configuration functionality, including support for: 

* Multiple ingress configurations per application
* Multiple ingress controllers within the same Runtime Fabric instance
* TLS and HTTPs configuration
* Custom URL naming
* URL parameter placeholders

== How Ingress Resources Templates Work in Runtime Fabric

The following diagram provides an overview of how to use ingress resource templates in Runtime Fabric:

image::ingress-diagram.png[Diagram shows the ingress template workflow in Runtime Fabric,80%]

. An IT administrator creates or modifies an ingress resource template using the necessary parameters. Various ingress controllers operate differently. Review your ingress controller’s documentation and adjust your annotations accordingly. 
. The IT admin applies the template using `kubectl apply` commands.
. From the applied template, Runtime Fabric creates placeholder URI domains and propagates the ingress configuration in Anypoint Runtime Manager as a template for all application deployments.
. A Mule application developer uses Runtime Manager to configure an application for deployment by selecting an available host, an optional subdomain, and a path combination, as specified in the ingress template. 
. Runtime Fabric receives the application deployment request and uses the ingress configurations from the template to create a corresponding ingress object in the cluster.

== Example Ingress Resource Templates

The following examples illustrate how to modify a Kubernetes ingress spec to create a Runtime Fabric ingress resource template. 

Use the API version appropriate to your Kubernetes version:

* Kubernetes v1.19 or later: 
** networking.k8s.io/v1 
** networking.k8s.io/v1beta1 
* Kubernetes v1.14 through v1.18: 
** only networking.k8s.io/v1beta1  

=== networking.k8s.io/v1

[NOTE]
====
This template is specific to Nginx as the ingress controller. The final configuration of the template varies depending on the controller and ingress routing rules you use. Review the documentation for your ingress controller carefully.
====

[source,yaml]
--
  kind: Ingress
  metadata:
    name: example-rtf-ingress
    namespace: rtf  #<1>                           
  spec:
    ingressClassName: rtf-nginx  #<2> 
    tls:  #<3>
    - hosts:
        - app-name.example.com
      secretName: example-tls
    rules:
    - hosts: app-name.example.com  #<4>
      http:
        paths:  #<5>
        - pathType: Prefix
          path: “/”
          backend:  #<6>
            service:
              name: service-name
              port:
                name: service-port
--

Note the following about this example:
  
<1>  The template must use the `rtf` namespace.

<2>  ingressClassName must be prefixed with `rtf-``, for example, `rtf-nginx`.
+
This is how Runtime Fabric recognizes the object as a template. A template that uses the `rtf-` prefix in the `ingressClassName`, for example, `rtf-nginx`, is consumed by the Runtime Fabric agent only and not by the actual ingress controller. Ingress controllers discover only resources with an `ingressClassName` value that uses the vendor-specific name, for example, `nginx` or `haproxy`.

<3> TLS is optional.

<4> `app-name` is a placeholder parameter that will be replaced with actual app name when you deploy the application.

<5> A template can include multiple hosts, but Runtime Manager displays the first path rule only.

<6>  These are placeholder values required for Kubernetes validation, but the actual values are not used by Runtime Fabric. 

=== networking.k8s.io/v1beta1

[source,yaml]
--
apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  name: example-ingress-template
  namespace: rtf #<1>
  annotations:
    kubernetes.io/ingress.class: rtf-nginx #<2>
  rules:
  - host: app-name.example.com
    http:
      Paths: #<3>
      - path: /
        pathType: 
        Backend: #<4>
          serviceName: service
          servicePort: 80
--

Note the following about this example:

<1>  The template must use the `rtf` namespace.

<2>  ingressClassName must be prefixed with `rtf-``, for example, `rtf-nginx`. 
+
This is how Runtime Fabric recognizes the object as a template. A template that uses the `rtf-`` prefix in `ingressClassName`, for example, `rtf-nginx`, is consumed by the Runtime Fabric agent only and not by the actual ingress controller. Ingress controllers discover only resources with an ingressClassName value that uses the vendor-specific name, for example, `nginx` or `haproxy`.

<3> A template can include multiple hosts, but Runtime Manager displays the first path rule only.

<4>  These are placeholder values required for Kubernetes validation, but the actual values are not used by Runtime Fabric.

=== Template Placeholders 

Replace the following placeholders in the appropriate location in the template. Placeholders must be lowercase.

[%header%autowidth.spread]
|===
|Name of Placeholder |Location |Example Value 
|`app-name`      |`path`, `host`, `annotation` a|

[source,yaml]
----
http:
 paths:
 - pathType: ImplementationSpecific
   path: /app-name/(/|$)(.*)
----

|`business-group-id` |`path`, `host`, `annotation` a|

[source,yaml]
----
labels:
  business: 
  business-group-id
----

|`environment-id` |`path`, `host`, `annotation` a|

[source,yaml]
----
labels:
  environment: 
  environment-id
----
     
|===

== Configure Ingress for a Mule Application Deployment in Runtime Fabric

To configure ingress, complete the following tasks:

. Create an ingress resource template and apply it in the cluster.
. Configure a public endpoint for a Mule application deployment.

=== Create an Ingress Resource Template and Apply It in the Cluster

Use one of the xref:example-ingress-resource-templates[example templates] to create an ingress resource. 

. Copy the example template into a new file and modify it according to the notes. 
. Include a `.yaml` extension in the file name. 
. To apply an ingress template, log in to a Kubernetes workstation and run:
+
`kubectl apply -f <TEMPLATE_FILENAME.yaml>`

If there is an issue in the template, Kubernetes `api-server` returns an error and the command fails. 

After you apply a template successfully, you can view it with:

`kubectl describe ingress [Ingress Name] -n rtf`

=== Configure a Public Endpoint for a Mule Application Deployment 

You configure public endpoints for an application when you’re ready to deploy it to Runtime Fabric using Runtime Manager. Available hosts and paths for an application come from the ingress resource template configured by the Runtime Fabric administrator. 

You can also use this procedure to deploy a test application to validate your ingress resource template.
 
[NOTE]
====
Deploying a Mule application is a larger process, but the following provides an overview of how to configure ingress for an application. Refer to Deploy a Mule Application to Runtime Fabric for complete deployment instructions.
==== 

. Navigate to Runtime Manager and follow the documentation to deploy an application to Runtime Fabric.
. Select *Ingress*.
. From the *Host* drop-down list, select a host for the application. 
. If the hostname uses a wildcard, add a subdomain in the *Subdomain* field. 
+
The *Subdomain* field is only available if the hostname uses a wildcard.
. In the *Path* field, add a URL path to the application’s endpoint:
+
image::rtf-ingress-endpoint.png[The host and path fields are populated for the endpoint,80%]

. To preview the endpoint, click the generated preview link. 
+
If the path uses a regex, you might need to manually modify the endpoint URL in your browser.

. To add additional endpoints, click *+ Add Endpoint*.
. When ready, click *Deploy application*.  

== Existing Ingress Configurations Translated on Upgrade 

When you upgrade to Runtime Fabric version 1.10, the upgrade process automatically translates any existing ingress ConfigMaps to the ingress resource template format, including annotations, path, namespace, and host parameters. Review the table below to determine if any action is required after you upgrade.

[%header%autowidth.spread]
|===
|Runtime Fabric Pre-upgrade |Runtime Fabric Upgraded |Action Required |TLS Support
|No domains configured and no ingress-ConfigMap applied |Generated template will contain `*` for hosts and will include `/app-name` in the path |Edit the `host` field in the generated template to provide a valid host/domain for deploying applications in Runtime Manager|No TLS section added by default 
|No domains configured, but a valid ingress-ConfigMap applied |Generated template will contain `*` for hosts and will contain the path and annotations from the previous ingress-ConfigMap |Edit the `host` field in the generated template to provide a valid host/domain for deploying applications in Runtime Manager | No TLS section added by default
|Valid domains configured, but no ingress-ConfigMap applied |Generated templates will contain one host per domain per template and will include `/app-name` in the path for each template |No immediate action required, unless the domains use `https://`; in this case, configure a TLS secret in the template corresponding to the  HTTPS domain |For domains that have `https://`, the template corresponding to that domain will have a TLS section without a secret attribute
|Valid domains configured and a valid ingress-ConfigMap applied |Generated templates will contain one host per domain per template and will include all the paths and annotations from the previous ingress-ConfigMap |No immediate action required, unless the domains use `https://`; in this case, configure a TLS secret in the template corresponding to the HTTPS domain |For domains that have `https://`, the template corresponding to that domain will have a TLS section without a secret attribute
|===

== Troubleshooting Ingress Issues

If you encounter errors when attempting to use ingress for Runtime Fabric, troubleshoot them as follows.

=== Mule App Deployed But Cannot Access Its Endpoint

Scenario: You successfully deploy a Mule application in Runtime Manager, but you cannot access the application’s endpoint.

To troubleshoot this issue: 

. Verify that the application is listening on port 8081:
+
`kubectl port-forward -n [NAMESPACE] svc/<APP_NAME> 8081:8081` 

. Verify that the application is running and responding to HTTP requests:
+
`curl -v http://127.0.0.1:8081/`
+
This helps determine if the API access issue is on the Mule app itself.  

. Validate that an ingress resource exists for that application service: 
+
`kubectl get ingress -n [NAMESPACE]`

. Validate that the service was created:
+
`kubectl get svc -n [NAMESPACE]`
+
If not, check the Runtime Fabric agent logs:
+
`kubectl logs -n rtf [AGENT_POD_NAME] -f`

If the service and ingress object look healthy, see additional troubleshooting tasks. 

=== Ingress Resource Created in Cluster But Cannot Access Its Endpoint

Scenario: Runtime Fabric successfully creates an ingress resource in the cluster but you cannot access the application’s endpoint due to a 404 error. 

To troubleshoot this issue: 

. Verify the ingress and service resources:
+
----
kubectl get ingress -n<APP-NAMESPACE>
kubectl get svc -n<APP-NAMESPACE>
----
+
The results should be similar to:
+
----
# kubectl get ingress -n<<APP-NAMESPACE>                             
NAME                           CLASS       HOSTS               ADDRESS       PORTS     AGE
<INGRESS_RESOURCE>            <INGRESS>    <HOSTNAME>.com      <HOST IP>     80, 443   7m3s

#kubectl get svc -n<<APP-NAMESPACE>                                
NAME             TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)                      AGE
test-rc-1        ClusterIP   <CLUSTER IP>   <none>        8081/TCP,8082/TCP,5701/TCP   8m5s
----

. Check the ingress resource for your app to ensure that the HTTP path in the resource, annotations, and host are correctly rendered:
+
`kubectl get ing -n<APP-NAMESPACE> -oyaml`

The results should be similar to:

[source,yaml]
--
# kubectl get ing -n<APP-NAMESPACE> -oyaml
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /$2
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
  creationTimestamp: "2021-07-29T21:22:14Z"
  generation: 1
  labels:
    bg: <BUSINESS-GROUP-ID>
    environment: <ENVIRONMENT-ID>
    ingress.rtf.mulesoft.com/svcName: <APP_NAME>
    ingress.rtf.mulesoft.com/svcVersion: <UUID>
  managedFields:
  - apiVersion: networking.k8s.io/v1
…
…
spec:
  ingressClassName: <INGRESS-CLASS>
  rules:
  - host: <SELECTED-HOST>
    http:
      paths:
      - backend:
          serviceName: <APP_NAME>
          servicePort: 8081
        path: /<PATH-FROM-TEMPLATE>
        pathType: ImplementationSpecific
  tls:
  - hosts:
    - <SELECTED-HOST>
    secretName: <TLS-SECRET-NAME>
status:
  loadBalancer:
    ingress:
    - ip: <IP-ADDRESS>
--

. Check the application pod logs to ensure that you’ve configured the correct listening port:
+
`kubectl logs -f -n<APP-NAMESPACE> <APP-POD-NAME> -c app`

The results should be similar to:

----
# kubectl logs -f -n<<APP-NAMESPACE> -c app
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ Starting app '<APP_NAME>'                                                     +
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
[2021-07-29 21:22:37.842] INFO  QueueXaResourceManager [ArtifactDeployer.start.01] [event: ]: Starting ResourceManager
[2021-07-29 21:22:37.842] INFO  QueueXaResourceManager [ArtifactDeployer.start.01] [event: ]: Started ResourceManager
[2021-07-29 21:22:37.846] INFO  AbstractLifecycleManager [ArtifactDeployer.start.01] [event: ]: Starting Bean: org.mule.runtime.module.extension.internal.runtime.config.ConfigurationProviderToolingAdapter-HTTP_Listener_config
[2021-07-29 21:22:37.859] INFO  GrizzlyHttpServer [ArtifactDeployer.start.01] [event: ]: Listening for connections on 'http://0.0.0.0:8081'
[2021-07-29 21:22:37.874] INFO  FlowConstructLifecycleManager [ArtifactDeployer.start.01] [event: ]: Starting flow: sample-json-backendFlow
[2021-07-29 21:22:38.171] INFO  AbstractLifecycleManager [ArtifactDeployer.start.01] [event: ]: Starting Bean: listener
[2021-07-29 21:22:38.178] INFO  LogUtil [ArtifactDeployer.start.01]:
----

In the logs, verify that the listener port matches the service port discovered in Step 1.

If the port is correct, check the application logs to verify that the application is receiving requests from the ingress controller.

=== Ingress Resource Not Recognized by AWS Application Load Balancer

Scenario: When using an AWS ALB, you can’t access an application’s endpoint, even though you successfully deployed the application and endpoint. 

If you’re using AWS Load Balancer Controller for ingress, you must specify the `kubernetes.io/ingress.class: alb` annotation in the template, _not_ `ingressClassName: alb`. AWS Load Balancer Controller requires the `ingress.class` annotation to discover and create L7 load balancers for deployed ingress resources for those annotations.